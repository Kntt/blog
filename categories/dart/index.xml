<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dart on Kntt&#39;s Blog</title>
    <link>http://liuys.me/categories/dart/index.xml</link>
    <description>Recent content in Dart on Kntt&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <atom:link href="http://liuys.me/categories/dart/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[Flutter-前端视角]学习总结</title>
      <link>http://liuys.me/blog/flutter-dart-4/</link>
      <pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://liuys.me/blog/flutter-dart-4/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://liuys.me/blog/flutter-dart-1/&#34; title=&#34;[Flutter-前端视角]dart语言学习笔记（1）&#34;&gt;[Flutter-前端视角]dart语言学习笔记（1）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://liuys.me/blog/flutter-dart-2/&#34; title=&#34;[Flutter-前端视角]dart语言学习笔记（2）&#34;&gt;[Flutter-前端视角]dart语言学习笔记（2）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://liuys.me/blog/flutter-dart-3/&#34; title=&#34;[Flutter-前端视角]dart语言学习笔记（3）&#34;&gt;[Flutter-前端视角]dart语言学习笔记（3）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;对应的前端html标签&#34;&gt;对应的前端HTML标签&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;HTML里面的标签在flutter里面叫做&lt;code&gt;Widget&lt;/code&gt;,但是&lt;code&gt;Widget&lt;/code&gt;并不是html里面的标签，因为css里面的一些属性也处理成相应的&lt;code&gt;Widget&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;也就是说&lt;code&gt;Widget&lt;/code&gt;包含标签和CSS属性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;h1～h6,p,span文字相关标签&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;// Text类，可以看作是块级的文字显示
new Text(
    &amp;quot;Lorem ipsum&amp;quot;,
    style: new TextStyle(
        fontSize: 24.0
        fontWeight: FontWeight.w900,
        fontFamily: &amp;quot;Georgia&amp;quot;,
    ),
)

// 行内文字使用TextSpan类
new TextSpan(
    style: bold24Roboto,
    children: &amp;lt;TextSpan&amp;gt;[
    new TextSpan(text: &amp;quot;Lorem &amp;quot;),
    new TextSpan(
      text: &amp;quot;ipsum&amp;quot;,
      style: new TextStyle(
        fontWeight: FontWeight.w300,
        fontStyle: FontStyle.italic,
        fontSize: 48.0,
      ),
    ),
    ],
)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这两个类都只能处理文字样式，fontsize， fontweight等。间距等属性要借助其他类去处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;img标签&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;// 网络图片
Image.network(&#39;networkUrl&#39;)
// or
NetworkImage(&#39;networkUrl&#39;)

// 本地图片
Image.asset(&#39;assetsUrl&#39;)
// or
AssetImage(&#39;assetsUrl&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;第一个使用方式是&lt;code&gt;Image&lt;/code&gt;类的命名构造函数，第二种用法是针对命名构造函数单独声明的类，没什么区别；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;div标签&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;new Container(
    color: Color(0xFFDDDDDD), // decoration
    width: 100.0,
    height: 100.0,
    padding: EdgeInsets.all(10.0), // decoration
    margin: EdgeInsets.all(10.0), // decoration
    child: new Text(&#39;lorem ~~&#39;),
)
// 等价于HTML
&amp;lt;style&amp;gt;
.container {
    width: 100px;
    height: 100px;
    background-color: #DDDDDD;
    padding: 10px;
    margin: 10px;
}
&amp;lt;/style&amp;gt;
&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;lorem ~~&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Container&lt;/code&gt;类，还有其他参数，注释有decoration的参数，可以统一在decoration参数中实现，decoration参数和注释有decoration的参数是互斥的（如果decoration参数存在，其他属性就不需要了，都需要在decoration参数中去处理） decoration参数的类型是实现&lt;code&gt;Decoration&lt;/code&gt;类的类或子类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;new Container(
    decoration: new BoxDecoration(
        // color: Colors.red,
        gradient: new LinearGradient(
            colors: [
                Colors.red,
                Colors.blue,
            ],
        ),
        padding: EdgeInsets.all(10.0),
        margin: EdgeInsets.all(10.0),
        border: Border.all(width: 1.0, color: Colors.black),
        borderRadius: BorderRadius.circular(8.0),
    ),
)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;decoration参数 &amp;lt;===&amp;gt; HTML 属性 &lt;code&gt;background&lt;/code&gt;, &lt;code&gt;border&lt;/code&gt;, &lt;code&gt;border-radius&lt;/code&gt;, &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;padding&lt;/code&gt;，&lt;code&gt;box-shadow&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;html中的常见场景在flutter中的实现&#34;&gt;HTML中的常见场景在flutter中的实现&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://flutterchina.club/web-analogs/&#34;&gt;flutter文档于web开发者视角&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里我讲一些没有介绍的， 以及我学习过程中遇到的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;复杂背景的实现&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;最简单的办法是使用图片作为背景， 但是使用图片有些弊端，比如适配～。背景带动画效果的，使用图片也实现不了～&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决思路：通过Widget来实现复杂的效果，最终把实现的Widget作为页面背景&lt;/p&gt;

&lt;p&gt;和web开发类比一下：两个div标签，一个div用来实现背景，一个div装内容，最终通过定位，使得两个div重叠在一起，通过zindex控制层级，最终达到想要的视觉效果&lt;/p&gt;

&lt;p&gt;当然在flutter里面的思路也是一样的：不同的是flutter中有一个Widget，叫&lt;code&gt;Stack&lt;/code&gt;
&lt;a href=&#34;https://docs.flutter.io/flutter/widgets/Stack-class.html&#34;&gt;可以允许其子widget简单的堆叠在一起&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Stack(
      children: &amp;lt;Widget&amp;gt;[
        Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8.0),
            color: Color(0xFF0071EF),
            boxShadow: &amp;lt;BoxShadow&amp;gt;[
              new BoxShadow (
                color: const Color(0xFF0071EF),
                offset: new Offset(0.0, 16.0),
                blurRadius: 24.0,
                spreadRadius: -16.0
              ),
            ]
          ),
        ), // 实现boxshadow
        Row(
          children: &amp;lt;Widget&amp;gt;[
            new Expanded(
              flex: 1,
              child: new ClipPath(
                clipper: new ClipperOne(),
                child: Container(
                  decoration: new BoxDecoration(
                    gradient: new LinearGradient(
                      begin: Alignment.bottomRight,
                      end: Alignment.topRight,
                      colors: [
                        Color(0xFF0071EF),
                        Color(0xFF2688F6),
                      ],
                    )
                  ),
                  height: 184.0,
                ),
              ),
            ),
            new Expanded(
              flex: 1,
              child: new ClipPath(
                clipper: new ClipperTwo(),
                child: Container(
                  decoration: new BoxDecoration(
                    gradient: new LinearGradient(
                      begin: Alignment.centerRight,
                      end: Alignment.bottomLeft,
                      colors: [
                        Color(0xFF0071EF),
                        Color(0xFF2688F6),
                      ],
                    )
                  ),
                  height: 184.0,
                ),
              ),
            ),
          ],
        ), // 复杂的背景
        Padding(
          padding: EdgeInsets.symmetric(horizontal: 24.0, vertical: 32.0),
          child: Text(&#39;lorem content&#39;),
        ), // 上层的内容
      ],
    )

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.滚动&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;web中可以直接通过overflow来实现，在flutter中提供的特定功能的Widget
&lt;code&gt;SingleChildScrollView&lt;/code&gt;, &lt;code&gt;ListView&lt;/code&gt; 等～&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;new ListView.builder(
  padding: new EdgeInsets.all(8.0),
  itemExtent: 20.0,
  itemBuilder: (BuildContext context, int index) {
    return new Text(&#39;entry $index&#39;);
  },
)

SingleChildScrollView(
    child: Column(
        children: &amp;lt;Widget&amp;gt;[
            appBarColumn(),  // 自定义组件
            swiperCard(), // 自定义组件
            actionsCard(), // 自定义组件
        ],
    ),
)

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;滚动容器显示滚动条&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;ScrollBar&lt;/code&gt;这个Widget&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Scrollbar(
    child: new ListView.builder(
        padding: new EdgeInsets.all(8.0),
        itemExtent: 20.0,
        itemBuilder: (BuildContext context, int index) {
            return new Text(&#39;entry $index&#39;);
        },
    )
)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;点击事件&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;InkWell&lt;/code&gt;或者button相关的Widget都有onPressed或onTap参数来实现点击&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;InkWell(
    onTap: () { print(&#39;onTap&#39;); },
    child: Container(
        child: Text(&#39;tap&#39;)
    ),
)

FlatButton(
    onPressed: () { print(&#39;onPressed&#39;); },
    child: Text(&#39;button&#39;),
)
// 图片点击跳转 没有a标签之类的Widget, 可以考虑自定义Widget，模拟web方式

InkWell(
    onTap: () { Navigator.push(context, route) },
    child: Image.asset(&#39;assetUrl&#39;),
)

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;事件监听&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;flutter中常用的widget&#34;&gt;flutter中常用的Widget&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://flutterchina.club/widgets/&#34;&gt;Widgets 目录&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Container&lt;/code&gt;, &lt;code&gt;BoxDecoration&lt;/code&gt;，相当于div标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;TextStyle&lt;/code&gt; 文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Flex&lt;/code&gt;, &lt;code&gt;Row&lt;/code&gt;, &lt;code&gt;Collumn&lt;/code&gt;, &lt;code&gt;Expanded&lt;/code&gt;, &lt;code&gt;Flexible&lt;/code&gt; 使用flex布局的相关Widget&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Image&lt;/code&gt; 图片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ListView&lt;/code&gt;, &lt;code&gt;SingleChildScrollView&lt;/code&gt; 滚动容器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FlatButton&lt;/code&gt;, &lt;code&gt;RaisedButton&lt;/code&gt;, &lt;code&gt;IconButton&lt;/code&gt;, &lt;code&gt;FloatingActionButton&lt;/code&gt;, &lt;code&gt;PopupMenuButton&lt;/code&gt;, &lt;code&gt;ButtonBar&lt;/code&gt; 按钮&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Padding&lt;/code&gt;, &lt;code&gt;Center&lt;/code&gt;, &lt;code&gt;Stack&lt;/code&gt;, &lt;code&gt;Color&lt;/code&gt; 属性相关的Widget&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Icons&lt;/code&gt;, &lt;code&gt;Colors&lt;/code&gt;, &lt;code&gt;Alignment&lt;/code&gt;, &lt;code&gt;Axis&lt;/code&gt; 枚举&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;HTML通过标签嵌套来实现的tree结构，flutter通过child或者children参数实现tree结构&lt;/li&gt;
&lt;li&gt;flutter中没有css中class的概念， 想实现样式复用，可以通过自定义Widget来实现（虽然可以实现，但是复用率不高，好多样式还是要重复写的，比如背景颜色是红色，不同的widget没办法抽离通用class，这里没有css方便）&lt;/li&gt;
&lt;li&gt;等待补充～&lt;/li&gt;
&lt;li&gt;学习过程写的项目
&lt;a href=&#34;https://github.com/Kntt/flutter-app-study&#34;&gt;项目地址:https://github.com/Kntt/flutter-app-study&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>[Flutter-前端视角]dart语言学习笔记（3）</title>
      <link>http://liuys.me/blog/flutter-dart-3/</link>
      <pubDate>Mon, 20 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://liuys.me/blog/flutter-dart-3/</guid>
      <description>

&lt;h3 id=&#34;类和对象&#34;&gt;类和对象&lt;/h3&gt;

&lt;p&gt;Dart是一门使用类和单继承的面向对象语言
&amp;gt;所有的对象都是类的实例，并且所有的类都是&lt;code&gt;Object&lt;/code&gt;的子类&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;类的定义用&lt;code&gt;class&lt;/code&gt;关键字&lt;/p&gt;

&lt;p&gt;如果未显式定义构造函数，会默认一个空的构造函数&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;new&lt;/code&gt;关键字和构造函数来创建对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.构造函数&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果只是简单的参数传递，可以在构造函数的参数前加&lt;code&gt;this&lt;/code&gt;关键字定义或者参数后加&lt;code&gt;:&lt;/code&gt; 再赋值&lt;/p&gt;

&lt;p&gt;没有函数体的函数可以直接写&lt;code&gt;;&lt;/code&gt;来结束函数声明&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Point {
    num x;
    num y;
    num z;
     // 第一个值传递给this.x，第二个值传递给this.y, 类似js中的解构赋值
    Point(this.x, this.y, z) {
            this.z = z;
    }
    // 命名构造函数，格式为Class.name(var param)
    Point.fromList(var list): x = list[0], y = list[1], z=list[2];

    //当然，上面句你也可以简写为：this相当于自身的构造函数
    //Point.fromList(var list):this(list[0], list[1], list[2]);

     String toString() =&amp;gt; &#39;x:$x  y:$y  z:$z&#39;;
}

void main() {
    var p1 = new Point(1, 2, 3);
    var p2 = new Point.fromList([1, 2, 3]);
    print(p1);//默认调用toString()函数
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你要创建一个不可变的对象，你可以定义编译时常量对象，需要在构造函数前加&lt;code&gt;const&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class ImmutablePoint {
    final num x;
    final num y;
    const ImmutablePoint(this.x, this.y); // 常量构造函数
}
static final ImmutablePoint origin = const ImmutablePoint(0, 0); 
// 创建一个常量对象不能用new，要用const
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;在flutter中使用方式的差异&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;import &#39;package:flutter/material.dart&#39;;

class ProfileTile extends StatelessWidget {
  final title;
  final subtitle;
  final textColor;
  ProfileTile({this.title, this.subtitle, this.textColor = Colors.black});
  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: &amp;lt;Widget&amp;gt;[
        Text(
          title,
          style: TextStyle(
            fontSize: 20.0,
            fontWeight: FontWeight.w700,
            color: textColor
          ),
        ),
        SizedBox(
          height: 4.0,
        ),
        Text(
          subtitle,
          style: TextStyle(
            fontSize: 15.0,
            fontWeight: FontWeight.normal,
            color: textColor
          ),
        ),
      ],
    );
  }
}
// 我们有注意到构造函数的参数多了｛｝
// 在使用时的不同就是:

new ProfileTile(
    title: &#39;xxx&#39;,
    subtitle: &#39;xxxx&#39;
)
// 这样通过构造函数我们可以直观的看出每个参数的含义
// 总结就是：不使用｛｝包裹参数的构造函数，是按着参数的顺序去相应的赋值
// 使用｛｝包裹的构造函数，参数是具名的， 不用关心顺序
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Getters And Setters&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Getter和Setter是用来读写一个对象属性的方法每个字段都对应一个隐式的&lt;code&gt;Getter&lt;/code&gt;和&lt;code&gt;Setter&lt;/code&gt;但是调用的时候是&lt;code&gt;obj.x&lt;/code&gt;，而不是&lt;code&gt;obj.x()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;你可以使用get和set关键字扩展功能如果字段为final或者const的话，那么它只有一个getter方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Rectangle {
    num left;
    num top;
    num width;
    num height;

    Rectangle(this.left, this.top, this.width, this.height);
    
    // right 和 bottom 两个属性的计算方法
    num get right =&amp;gt; left + width;
    set right(num value) =&amp;gt; left = value - width;
    num get bottom =&amp;gt; top + height;
    set bottom(num value) =&amp;gt; top = value - height;
}

main() {
    var rect = new Rectangle(3, 4, 20, 15);
    assert(rect.left == 3);
    rect.right = 12;
    assert(rect.left == -8);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;抽象类&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;在Dart中类和接口是统一的，类就是接口&lt;/p&gt;

&lt;p&gt;如果你想重写部分功能，那么你可以继承一个类，关键字 ==&lt;code&gt;extends&lt;/code&gt;==&lt;/p&gt;

&lt;p&gt;如果你想实现某些功能，那么你也可以实现一个类，关键字 ==&lt;code&gt;implements&lt;/code&gt;==&lt;/p&gt;

&lt;p&gt;使用 ==&lt;code&gt;abstract&lt;/code&gt;== 关键字来定义抽象类，并且抽象类==不能被实例化==&lt;/p&gt;

&lt;p&gt;抽象方法不需要关键字，直接以分号 ; 结束即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;abstract class Shape { // 定义了一个 Shape 类/接口
    num perimeter(); // 这是一个抽象方法，不需要abstract关键字，是隐式接口的一部分。
}

class Rectangle implements Shape { // Rectangle 实现了 Shape 接口
    final num height, width; 
    Rectangle(num this.height, num this.width);  // 紧凑的构造函数语法
    num perimeter() =&amp;gt; 2*height + 2*width;       // 实现了 Shape 接口要求的 perimeter 方法
}

class Square extends Rectangle { // Square 继承 Rectangle
    Square(num size) : super(size, size); // 调用超类的构造函数
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;工厂构造函数&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;Factory单独拿出来讲，因为这不仅仅是构造函数，更是一种模式&lt;/p&gt;

&lt;p&gt;有时候为了返回一个之前已经创建的缓存对象，原始的构造方法已经不能满足要求&lt;/p&gt;

&lt;p&gt;那么可以使用工厂模式来定义构造函数&lt;/p&gt;

&lt;p&gt;并且用关键字new来获取之前已经创建的缓存对象&lt;/p&gt;

&lt;p&gt;私有变量前面增加下划线，dart没有private前缀&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;class Logger { 
    final String name; 
    bool mute = false; 
    
    // 变量前加下划线表示私有属性 
    static final Map&amp;lt;String, Logger&amp;gt; _cache = &amp;lt;String, Logger&amp;gt;{}; 
    
    factory Logger(String name) { 
        if (_cache.containsKey(name)) { 
            return _cache[name]; 
        } else { 
            final logger = new Logger._internal(name); 
            _cache[name] = logger; 
            return logger; 
        } 
    }
    // 私有命名构造函数
    Logger._internal(this.name); 
    
    void log(String msg) { 
        if (!mute) { 
            print(msg); 
        } 
    } 
} 

var logger = new Logger(&#39;UI&#39;); 
logger.log(&#39;Button clicked&#39;);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>[Flutter-前端视角]dart语言学习笔记（2）</title>
      <link>http://liuys.me/blog/flutter-dart-2/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://liuys.me/blog/flutter-dart-2/</guid>
      <description>

&lt;h3 id=&#34;标记特殊需要记忆的点&#34;&gt;标记特殊需要记忆的点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;取整&lt;code&gt;~/&lt;/code&gt;操作符之前可能很少看到，代码如下&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;int a = 3；
int b = 2；
print(a~/b);//输出1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.级联操作符，当你要对一个单一的对象进行一系列的操作的时候，
可以使用级联操作符 &lt;code&gt;..&lt;/code&gt;(相当于js的链式调用，隐式的返回原对象)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person {
    String name;
    String country;
    void setCountry(String country){
      this.country = country;
    }
    String toString() =&amp;gt; &#39;Name:$name\nCountry:$country&#39;;
}
void main() {
  Person p = new Person();
  p ..name = &#39;Wang&#39;
    ..setCountry(&#39;China&#39;);
  print(p);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;If&lt;/code&gt;语句的判断条件为==bool==值，用法和大多语言一样（只接受布尔值， 其他类型的值都译为&lt;code&gt;false&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;if(i&amp;lt;0){
  print(&#39;i &amp;lt; 0&#39;);
}else if(i ==0){
  print(&#39;i = 0&#39;);
} else {
  print(&#39;i &amp;gt; 0&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;循环 &lt;code&gt;for forEach for-in&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;for(int i = 0; i&amp;lt;3; i++) {
  print(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果迭代的对象是容器，那么可以使用&lt;code&gt;forEach&lt;/code&gt;或者&lt;code&gt;for-in&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var collection = [0, 1, 2];

// forEach的参数为Function
collection.forEach(print);

for(var x in collection) {
  print(x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;do-while&lt;/code&gt;没有什么变化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while(boolean){
  //do something
}
 
do{
  //do something
} while(boolean)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.&lt;code&gt;swith&lt;/code&gt;的参数可以是&lt;code&gt;num&lt;/code&gt;，或者&lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var command = &#39;OPEN&#39;;
switch (command) {
  case &#39;CLOSED&#39;:
    break;
  case &#39;OPEN&#39;:
    break;
  default:
    print(&#39;Default&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特殊用法，使用==continue== &amp;amp; flag ,其他和js没什么区别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var command = &#39;CLOSED&#39;;
  switch (command) {
    case &#39;CLOSED&#39;:
      print(&#39;CLOSED&#39;);
      continue nowClosed; // Continues executing at the nowClosed flag.
    case &#39;OPEN&#39;:
      print(&#39;OPEN&#39;);
      break;
    nowClosed: // Runs for both CLOSED and NOW_CLOSED.
    case &#39;NOW_CLOSED&#39;:
      print(&#39;NOW_CLOSED&#39;);
      break;
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>[Flutter-前端视角]dart语言学习笔记（1）</title>
      <link>http://liuys.me/blog/flutter-dart-1/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://liuys.me/blog/flutter-dart-1/</guid>
      <description>

&lt;h4 id=&#34;一-基础数据类型-一切皆对象&#34;&gt;一. 基础数据类型 - 一切皆对象&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Numbers&lt;/li&gt;
&lt;li&gt;Strings&lt;/li&gt;
&lt;li&gt;Booleans&lt;/li&gt;
&lt;li&gt;Lists&lt;/li&gt;
&lt;li&gt;Maps&lt;/li&gt;
&lt;li&gt;Runes (用于在字符串中表示 Unicode 字符) &amp;ndash; 后面继续看&lt;/li&gt;
&lt;li&gt;Symbols&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;声明变量 关键字&lt;code&gt;var&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; &lt;code&gt;final&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;a. var
    // 通过var声明变量，这一点和js没什么区别
b. const , final
    // 这两个关键字都是声明常量的（重点看下面的区别）
    
    final time = new DateTime.now(); //Ok
    const time = new DateTime.now(); //Error，new DateTime.now()不是const常量
    
    // const 声明的常量不能是变量， 也就是说不能是官方文档所说的运行时常量
    // final 声明的常量可以是运行时常量也可以是编译时常量（final包含const）
    // 例如：声明 PI 是个运行时常量  就用const PI = 3.14159
    
    // var、final等在左边定义变量的时候，并不关心右边是不是常量
    // 但是如果右边用了const，那么不管左边如何，右边都必须是常量
    
    const list = const[1,2,3];//Ok
    const list = [1,2,3];//Error
    
    final list = [1,2,3];//Ok
    final list = const[1,2,3];//Ok
    final list = const[new DateTime.now(),2,3];//Error,const右边必须是常量
    
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>